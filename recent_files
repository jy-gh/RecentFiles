#! /usr/bin/env python3

'''
Shows recently modified files, after applying an exclude filter,
in either JSON or text format. The JSON format is used for an
Alfred workflow.
'''

import argparse
import io
import json
import os
import subprocess
import sys

FD_COMMAND = '/opt/local/bin/fd'
FD_DEFAULT_FILETYPE = 'f'

class FindRecentFiles:
    '''Uses the fd command to find recent files'''

    def __init__(self):
        '''Initialize variables'''

        self._parse_arguments()

        if self.arguments['dir'] is None:
            self.arguments['dir'] = os.getcwd()

        if self.arguments['filetypes'] is None:
            self.arguments['filetypes'] = []
            self.arguments['filetypes'].append(FD_DEFAULT_FILETYPE)

        if self.arguments['fd_command'] is None:
            self.arguments['fd_command'] = FD_COMMAND

        if not os.access(self.arguments['fd_command'], os.X_OK):
            print("Error: the configured fd command is not executable!")
            print("  " + self.arguments['fd_command'])
            sys.exit(1)

    def _parse_arguments(self):
        '''Parses command line arguments'''
        parser = argparse.ArgumentParser(description='Finds recent files')
        parser.add_argument(
            '-c', '--changed-within',
            dest='changed_within',
            default='7d',
            type=str,
            required=False,
            help='Changed within 1h, 2d, 5min, etc.; the default is 7d')
        parser.add_argument(
            '-d', '--dir',
            required=False,
            help='Directory to start search from, the default is the current directory')
        parser.add_argument(
            '-i', '--ignore-file',
            dest='ignore_file',
            type=str,
            required=False,
        parser.add_argument(
            '--fd-command',
            dest='fd_command',
            type=str,
            required=False,
            help='Path to the fd(1) command; the default is ' + FD_COMMAND)
        parser.add_argument(
            '-l', '--limit',
            type=int,
            default=-1,
            required=False,
            help='Limit number of results')
        parser.add_argument(
            '-o', '--output-format',
            dest='output_format',
            choices=['text', 'json'],
            required=False,
            default='text',
            help='Output format, default is text')
        parser.add_argument(
            '-t', '--filetype',
            dest='filetypes',
            choices=['f', 'd', 'l', 's', 'p', 'x', 'e'],
            required=False,
            action='append',
            help='Filetype, as supported by fd(1), default is "f"')

        parsed_arguments = parser.parse_args()
        self.arguments = vars(parsed_arguments)

    def _set_options(self):
        '''Set up the command line options for the fd command'''
        options = []

        options.append('-a')

        options.append('--changed-within')
        options.append(self.arguments['changed_within'])

        for filetype in self.arguments['filetypes']:
            options.append('-t')
            options.append(filetype)

        if 'ignore_file' in self.arguments and self.arguments['ignore_file'] is not None:
            options.append('--ignore-file')
            options.append(self.arguments['ignore_file'])

        return options

    def find_recent_files(self):
        '''Run the fd command, parse the result, and get file mtime values'''
        files = {}
        options = self._set_options()
        result_count = 0

        result = subprocess.Popen(
            [self.arguments['fd_command'], *options],
            stdout=subprocess.PIPE,
            cwd=self.arguments['dir'])

        for line in io.TextIOWrapper(result.stdout, encoding="utf-8", newline=''):
            result_count += 1
            filename = line.rstrip('\n')

            files[filename] = os.stat(filename).st_mtime
            if self.arguments['limit'] == result_count:
                break

        return files

    @staticmethod
    def create_json(sorted_list):
        '''Prepare and return JSON output'''
        files = []
        for list_item in sorted_list:
            filename = list_item[0]
            record = {
                'type': 'file',
                'title': filename,
                'subtitle': filename,
                'arg': filename,
            }
            files.append(record)

        items = { 'items': files }

        print(json.dumps(items))

    @staticmethod
    def create_text(sorted_list):
        '''Prepare and return plain text output'''
        for list_item in sorted_list:
            print(list_item[0])

    def run(self):
        '''Main program'''

        files = self.find_recent_files()
        sorted_list = sorted(files.items(), key=lambda x:x[1], reverse=True)
        if self.arguments['output_format'] == 'json':
            self.create_json(sorted_list)
        else:
            self.create_text(sorted_list)


if __name__ == '__main__':
    program = FindRecentFiles()
    program.run()
